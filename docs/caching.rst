*******
Caching
*******

There happens a lot under the hood when Django processes a request. And for
complex features creating a response can become quite slow because querying the
database and rendering the templates takes too much time. So instead of
performing the expansive operations over and over it makes more sense to store
the result and reuse it. This is what caching does.

Django offers different levels of cache granularity:

* You can cache only the pieces that are difficult to produce
* You can cache the output of specific views
* You can cache your entire site

And Django supports different cache backends:

* Memcached
* Database caching
* Filesystem caching
* Local-memory caching
* Dummy caching

In addition third party apps are available that support other cache backends
like Redis.

Setting up the cache
====================

To keep the local setup simple we are going to use local-memory caching. This
is the default so we don't have to configure anything.

For development it can be useful to use the dummy caching, otherwise changes
would need some time to appear. Simply set the ``BACKEND`` of the default cache
to ``DummyCache``:

::

    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
        }
    }

As you can see ``CACHES`` is a dictionary like ``DATABASES``, which means that
more than one cache backends can be used.

There are a few additional settings that need to changed according to the
requirements of the project.

* ``TIMEOUT``: The default timeout, in seconds, to use for the cache. This argument defaults to ``300`` seconds (5 minutes). You can set the value to ``None`` which lets the cache never expire or to ``0`` which lets the cache expire immediately (useful for development).
* ``OPTIONS``: Is a dictionary with options passed to the cache backend

    * ``MAX_ENTRIES``: The maximum number of entries allowed in the cache before old values are deleted. This argument defaults to ``300``. This setting correlates with the total size of your cache.
    * ``VERSION``: The version number for cache keys generated by the Django server. You should increment/change it every time you deploy a new release.

Here is an example cache configuration:

::

    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
            'LOCATION': '/var/tmp/django_cache',
            'TIMEOUT': 600,
            'OPTIONS': {
                'MAX_ENTRIES': 1000,
                'VERSION': 42,
            }
        }
    }

Template fragment caching
=========================

Caching single views or even the whole makes not much sense for our project
because dynamic parts like the login would never change, even if a user would
perform a login. Another thing that must not be cached are the CSRF tokens in
the forms. Otherwise no user would be able to submit a form.

Therefore we will cache the template fragments that produce the highest query
count. The :ref:`debug_toolbar` is very helpful for this. It can display all
database queries that are performed to render a page and also the cache hits.
So it's a perfect tool for optimizing a page.

For example we could cache the detail page of every recipe:

..  code-block:: html+django

    {% extends "base.html" %}

    {% load cache %}
    {% load i18n %}

    {% get_current_language as LANGUAGE_CODE %}

    {% block title %}
    {% cache 300 recipe_title object.pk LANGUAGE_CODE %}
    {{ block.super }} - {{ object.title }}
    {% endcache %}
    {% endblock %}

    {% block content %}
    {% cache 300 recipe object.pk LANGUAGE_CODE %}
    <h2>{{ object.title }}</h2>
    <p>Makes {{ object.number_of_portions }} servings.</p>
    <h3>Ingredients</h3>
    {{ object.ingredients|linebreaks }}
    <h3>Preparation</h3>
    {{ object.preparation|linebreaks }}
    <p>Time for preparation: {{ object.time_for_preparation }} minutes</p>
    <a href="{% url 'recipes_recipe_index' %}">back to the overview</a>
    {% endcache %}
    {% endblock %}

Another example would be the caching of the
``userauth/templates/userauth/toggle_login.html`` template:

..  code-block:: html+django

    {% load cache %}

    {% if user.is_authenticated %}
      {% cache 3600 user_toolbar user.username %}
      <ul class="nav navbar-nav">
        <li><a href="{% url 'recipes_recipe_add' %}">Add recipe</a></li>
      </ul>
      <ul class="nav pull-right">
        <li class="dropdown">
          <a class="dropdown-toggle" id="dropuser" data-toggle="dropdown" href="#">
            {{ user.username }}
          </a>
          <ul class="dropdown-menu" role="menu" aria-labelledby="dropuser">
            <li><a href="{% url 'userauth_password_change' %}">Change password</a></li>
            <li><a href="{% url 'userauth_logout' %}">Logout</a></li>
          </ul>
        </li>
      </ul>
      {% endcache %}
    {% else %}
      <ul class="nav navbar-nav">
        <li><a href="{% url 'userauth_register' %}">Register</a></li>
      </ul>
      <form class="navbar-form navbar-right" role="form" action="{% url 'userauth_login' %}"
          method="post" accept-charset="utf-8">
        <div class="form-group">
          <input type="text" placeholder="Username" class="form-control" name="username">
        </div>
        <div class="form-group">
          <input type="password" placeholder="Password" class="form-control" name="password">
        </div>
        {% csrf_token %}
        <button type="submit" class="btn btn-success">Login</button>
      </form>
    {% endif %}

The ``cached_property`` decorator
=================================

The ``@cached_property`` decorator caches the result of a method with a single
``self`` argument as a property. The cached result will persist as long as the
instance does, so if the instance is passed around and the function
subsequently invoked, the cached result will be returned.

The following example demonstrates the usage of the ``@cached_property``
decorator. Without the decorator the related recipes would be fetched twice
from the database.

::

    class Recipe(models.Model):
        ...

        @cached_property
        def related_recipes(self):
            categories = self.category.all()
            related_recipes = Recipe.objects.filter(
                difficulty__exact=self.difficulty, category__in=categories)
            return related_recipes.exclude(pk=self.id).distinct()

..  code-block:: html+django

    {% if object.related_recipes %}
      <h4>Related Recipes</h4>
      <ul>
      {% for recipe in object.related_recipes %}
        <li><a href="{{ recipe.get_absolute_url }}">{{ recipe.title }}</a></li>
      {% endfor %}
      </ul>
    {% endif %}

Further links to the Django documentation
=========================================

* :djangodocs:`Caching <topics/cache/>`
* :djangodocs:`The cached_property decorator <ref/utils/#django.utils.functional.cached_property>`
